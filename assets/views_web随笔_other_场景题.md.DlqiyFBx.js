import{_ as i,c as a,a2 as n,o as l}from"./chunks/framework.CjNeJe2C.js";const o=JSON.parse('{"title":"场景题","description":"","frontmatter":{"title":"场景题","date":"2024-11-06T00:00:00.000Z","tags":["面试"],"categories":["面试"]},"headers":[],"relativePath":"views/web随笔/other/场景题.md","filePath":"views/web随笔/other/场景题.md"}'),p={name:"views/web随笔/other/场景题.md"};function e(t,s,h,k,d,r){return l(),a("div",null,s[0]||(s[0]=[n(`<h2 id="前端截图实现" tabindex="-1">前端截图实现 <a class="header-anchor" href="#前端截图实现" aria-label="Permalink to &quot;前端截图实现&quot;">​</a></h2><p>前端如何产出一张图片，首先能想到的就是使用canvas绘制区域，然后转成一张图片。但是手动canvas绘制存在以下问题：</p><ul><li>不能使用ctx.drawImage直接将分享区域进行整体截图：ctx.drawImage 对 图片元素 Image、svg 元素、视频元素 Video、Canvas 元素、ImageBitmap 数据等可以被绘制，但是对于一般的其他 div 或者列表 li 元素它是不可以被绘制的</li><li>调用canvas绘制：需要进行布局计算，绘制起来也很繁琐，造成开发量大</li><li>需要解决一些样式问题/设备兼容问题</li></ul><p>介于以上原因，可以考虑使用开源npm来实现dom转图片功能。 以下是使用比较多的库：</p><ul><li><a href="https://github.com/tsayen/dom-to-image" target="_blank" rel="noreferrer">dom-to-image</a><img src="https://img.shields.io/github/stars/tsayen/dom-to-image.svg" alt="github star"> (最近一次更新在2017)</li><li><a href="https://github.com/bubkoo/html-to-image" target="_blank" rel="noreferrer">html-to-image</a> <img src="https://img.shields.io/github/stars/bubkoo/html-to-image.svg" alt="github star"></li><li><a href="https://github.com/niklasvh/html2canvas" target="_blank" rel="noreferrer">html2canvas</a> <img src="https://img.shields.io/github/stars/niklasvh/html2canvas.svg" alt="github star"></li></ul><p><a href="https://segmentfault.com/a/1190000040578497?sort=newest" target="_blank" rel="noreferrer">前端截图实现</a></p><h2 id="js-超过-number-最大值的数怎么处理" tabindex="-1">js 超过 Number 最大值的数怎么处理？ <a class="header-anchor" href="#js-超过-number-最大值的数怎么处理" aria-label="Permalink to &quot;js 超过 Number 最大值的数怎么处理？&quot;">​</a></h2><p>js 中 Number 类型能够表示的最大值是 <code>2^53 - 1</code>，也就是 <code>9007199254740991</code>，即 <code>16</code> 位。如果需要表示更大的数字，可以使用 <code>BigInt</code> <code>类型。BigInt</code> 是一种内置对象，它提供了一种方法来表示大于 <code>2^53 - 1</code> 的整数。BigInt 可以表示任意大的整数，而不受限于 <code>Number</code> 类型的限制。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bigNum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BigInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Number.MAX_SAFE_INTEGER) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BigInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bigNum); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 9007199254740992n</span></span></code></pre></div><p><code>BigInt</code> 类型的数字需要使用 <code>BigInt</code> 函数进行转换，并且数字后面需要加上 n 来表示这是一个 <code>BigInt</code> 类型的数字。</p><p>注意，<code>BigInt</code> 类型是 ECMAScript 2020 新增的特性，因此在某些浏览器中可能不被⽀持。如果需要在 不⽀持 BigInt 的环境中使用 BigInt，可以使用 polyfill 或者第三⽅库来实现。</p><h3 id="依赖外部库" tabindex="-1">依赖外部库 <a class="header-anchor" href="#依赖外部库" aria-label="Permalink to &quot;依赖外部库&quot;">​</a></h3><p>在 <code>JavaScript</code> 中，超过 N<code>umber.MAX_VALUE</code> 的数值被认为是 <code>Infinity</code> （正⽆穷大）。如果要 处理超过 <code>Number.MAX_VALUE</code> 的数值，可以使用第三⽅的 JavaScript 库，如 <code>big.js</code> 或 <code>bignumber.js</code> ，这些库可以处理任意精度的数值。 例如，使用 <code>big.js</code> 库可以将两个超过 <code>Number.MAX_VALUE</code> 的数相加：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> const big = require(&#39;big.js&#39;);</span></span>
<span class="line"><span> const x = new big(&#39;9007199254740993&#39;);</span></span>
<span class="line"><span> const y = new big(&#39;100000000000000000&#39;);</span></span>
<span class="line"><span> const result = x.plus(y);</span></span>
<span class="line"><span> console.log(result.toString()); // 输出：100009007194925474093</span></span></code></pre></div><p>这⾥创建了两个 <code>big.js</code> 对象 x 和 y ，分别存储超过<code> Number.MAX_VALUE</code> 的数值。通过 <code>plus</code> ⽅法将它们相加，得到了正确的结果。最后，通过 <code>toString</code> ⽅法将结果转换为字符串</p><h2 id="使用同一个链接-如何实现-pc-打开是-web-应用、手机打开是一个-h5-应用" tabindex="-1">使用同一个链接， 如何实现 PC 打开是 web 应用、⼿机打开是一个 H5 应用？ <a class="header-anchor" href="#使用同一个链接-如何实现-pc-打开是-web-应用、手机打开是一个-h5-应用" aria-label="Permalink to &quot;使用同一个链接， 如何实现 PC 打开是 web 应用、⼿机打开是一个 H5 应用？&quot;">​</a></h2><p>可以通过根据请求来源（<code>User-Agent</code>）来判断访问设备的类型，然后在服务器端进行适配。例如，可 以在服务器端使用 <code>Node.js</code> 的 <code>Express</code> 框架，在路由中对不同的 <code>User-Agent</code> 进行判断，返回不同的⻚ ⾯或数据。具体实现可以参考以下步骤：</p><ol><li>根据 <code>User-Agent</code> 判断访问设备的类型，例如判断是否为移动设备。可以使用第三⽅库如 <code>ua-parser-js</code> 进行 <code>User-Agent</code> 的解析。</li><li>如果是移动设备，可以返回一个 H5 页面或接口数据。</li><li>如果是 PC 设备，可以返回一个 web 应用页面或接口数据。 具体实现⽅式还取决于应用的具体场景和需求，以上只是一个大致的思路。</li></ol><h2 id="如何解决页面请求接口大规模并发问题" tabindex="-1">如何解决页面请求接口大规模并发问题 <a class="header-anchor" href="#如何解决页面请求接口大规模并发问题" aria-label="Permalink to &quot;如何解决页面请求接口大规模并发问题&quot;">​</a></h2><p>如何解决页面请求接口大规模并发问题， 不仅仅是包含了接口并发， 还有前端资源下载的请求并发。 应该说这是一个话题讨论了； 可以从以下几个方面来考虑如何解决这个并发问题:</p><ol><li>后端优化：可以对接口进行优化，采用缓存技术，对数据进行预处理，减少数据库操作等。使用集 群技术，将请求分散到不同的服务器上，提⾼并发量。另外可以使用反向代理、负载均衡等技术， 分担服务器压力。</li><li>做 BFF 聚合：把所有首屏需要依赖的接口， 利用服务中间层给聚合为一个接口。</li><li>CDN加速：使用CDN缓存技术可以有效减少服务器请求压力，提⾼⽹站访问速度。CDN缓存可以将 接口的数据存储在缓存服务器中，减少对原始服务器的访问，加速数据传输速度。</li><li>使用 WebSocket：使用 WebSocket 可以建⽴一个持久的连接，避免反复连接请求。WebSocket 可以实现双向通信，大幅降低服务器响应时间。</li><li>使用 HTTP2 及其以上版本， 使用多路复用。</li><li>使用浏览器缓存技术：强缓存、协商缓存、离线缓存、Service Worker 缓存 等⽅向。</li><li>聚合一定量的静态资源： 比如提取页面公用复用部分代码打包到一个⽂件里面、对图片进行雪碧图 处理， 多个图片只下载一个图片。</li><li>采用微前端⼯程架构： 只是对当前访问页面的静态资源进行下载， ⽽不是下载整站静态资源。</li><li>使用服务端渲染技术： 从服务端把页面首屏直接渲染好返回， 就可以避免掉首屏需要的数据再做 额外加载和执行。</li></ol><h2 id="大文件上传" tabindex="-1">大文件上传 <a class="header-anchor" href="#大文件上传" aria-label="Permalink to &quot;大文件上传&quot;">​</a></h2><p>大文件上传是一个比较常见的需求，下面是一个简单的实现思路：</p><ol><li>将大文件切片成多个小文件，每个小文件的大小可以根据实际情况进行调整，例如100KB。</li><li>将每个小文件上传到服务器，可以使用<code>FormData</code>对象来构建请求体，将小文件作为<code>FormData</code>的 一个字段进行上传。</li><li>在上传过程中，可以使用<code>ProgressEvent</code>对象的<code>loaded</code>和<code>total</code>属性来获取上传进度，并显示给 用户。</li><li>当所有小文件都上传完成后，服务器端可以将这些小文件合并成一个大文件，并返回给客户端。</li><li>客户端接收到大文件后，可以进行后续的处理，例如下载、预览等。</li></ol><p>下面是一个简单的实现示例：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将大文件切片成多个小文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sliceFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">file</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">chunkSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> chunks</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> file.size) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> end</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chunkSize, file.size);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> chunk</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> file.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(start, end);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    chunks.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(chunk);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chunks;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 上传小文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uploadChunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">chunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> formData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FormData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  formData.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;chunk&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, chunk);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  formData.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;index&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, index);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 发送请求</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 上传大文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uploadLargeFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">file</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">chunkSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> chunks</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sliceFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(file, chunkSize);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> total</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chunks.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uploaded </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uploadChunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(chunks[i], i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 监听上传进度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  uploadChunk.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onprogress</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    uploaded </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.loaded;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> progress</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (uploaded </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> file.size) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`上传进度：\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">progress</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}%\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 选择文件并上传</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fileInput</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;file-input&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fileInput.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;change&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> file</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.target.files[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  uploadLargeFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(file, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 每个切片大小为100KB</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>以上代码只是一个简单的示例，实际应用中可能需要考虑更多的细节，例如错误处理、重试机制、并发控制等。</p><h2 id="h5-如何解决移动端适配问题" tabindex="-1">H5 如何解决移动端适配问题 <a class="header-anchor" href="#h5-如何解决移动端适配问题" aria-label="Permalink to &quot;H5 如何解决移动端适配问题&quot;">​</a></h2><p>移动端适配问题是一个比较常见的问题，下面是一些常见的解决方案：</p><ol><li>使用媒体查询（Media Queries）：媒体查询可以根据不同的屏幕尺寸和分辨率来应用不同的样式，例如：</li></ol><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@media</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> screen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">max-width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">600</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 在屏幕宽度小于600px时应用的样式 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@media</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> screen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">min-width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">601</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 在屏幕宽度大于等于601px时应用的样式 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="2"><li>使用相对单位：相对单位如em、rem、vw、vh等可以使得元素的大小相对于其父元素或视口的大小进行调整，例如：</li></ol><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  font-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  font-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">rem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 相对于body的字体大小 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">vw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 相对于视口宽度的80% */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="3"><li>使用flex布局：flex布局是一种灵活的布局方式，可以使得元素的大小和位置相对于其父元素进行调整，例如：</li></ol><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  justify-content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">center</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  align-items</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">center</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  flex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 拉伸元素以填充可用空间 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="4"><li>使⽤ <code>flexible</code> 布局⽅案 将 <code>px</code> 转化为 <code>rem</code> 单位，并且动态计算根节点的字体⼤⼩，以适配不同的设备。例如使⽤<code>lib-flexible</code> 库</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/lib-flexible/0.3.4/flexible.js&quot;</span></span>
<span class="line"><span>&lt;/script</span></span>
<span class="line"><span>// index.js</span></span>
<span class="line"><span>import &#39;lib-flexible/flexible.js&#39;</span></span></code></pre></div><p>其中 <code>flexible.js</code> 会在⻚⾯加载时动态计算根节点的字体⼤⼩，并将 <code>px</code> 转化为 <code>rem</code> 单位。在样式中可以直接使⽤ <code>px</code> 单位，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>div {</span></span>
<span class="line"><span>  width: 100px;height: 100px;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这个 div 元素的⼤⼩会根据设备屏幕的宽度进⾏适配。 5. 使用viewport元标签：viewport元标签可以控制页面的缩放和布局，例如：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width=device-width, initial-scale=1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>以上是一些常见的解决方案，实际应用中可能需要根据具体的需求和场景来选择合适的解决方案。</p><h2 id="href-和-src-的区别" tabindex="-1">href 和 src 的区别？ <a class="header-anchor" href="#href-和-src-的区别" aria-label="Permalink to &quot;href 和 src 的区别？&quot;">​</a></h2><p><code>href</code> 和 <code>src</code> 都是HTML中的属性，但它们的⽤途和⾏为有所不同：</p><ul><li><code>href</code> 是Hypertext Reference的缩写，表⽰超⽂本引⽤。它⽤于在当前元素和⽂档之间建⽴链 接。常⻅的使⽤场景包括：link、a等元素。例如，当我们在link元素中使⽤href属性来链接CSS⽂ 件时，浏览器会识别该⽂档为CSS⽂档，并⾏下载该⽂档，同时**不会停⽌**对当前⽂档的处理。</li><li><code>src</code> 是source的缩写，表⽰资源的来源。它⽤于将指向的内容嵌⼊到⽂档中当前标签所在的位 置。常⻅的使⽤场景包括：img、script、iframe等元素。例如，当我们在script元素中使⽤src属性 来链接JavaScript⽂件时，浏览器在解析到该元素时，<strong>会暂停</strong>浏览器的渲染，直到该资源加载完毕</li></ul><p>简单来说， src ⽤于替换当前元素，⽽ href ⽤于在当前⽂档和引⽤资源之间建⽴联系。</p><h2 id="如何放大图片并保证宽高比不变" tabindex="-1">如何放⼤图⽚并保证宽⾼⽐不变？ <a class="header-anchor" href="#如何放大图片并保证宽高比不变" aria-label="Permalink to &quot;如何放⼤图⽚并保证宽⾼⽐不变？&quot;">​</a></h2><ol><li>只设置宽或⾼的其中⼀项，另⼀项设置为auto（或者不设置，默认就是auto）,这样是不会改变图⽚宽⾼⽐的。<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>img {</span></span>
<span class="line"><span>  width: 100%;</span></span>
<span class="line"><span>  height: auto; /* ⾼度⾃动调整以保持宽⾼⽐ */</span></span>
<span class="line"><span>}</span></span></code></pre></div></li><li>使⽤ <code>object-fit</code> ，其中 <code>cover</code> 属性和 <code>container</code> 属性都可以保持宽⾼⽐不变，其区别在于</li></ol><ul><li><code>object-fit: cover</code>; ：被替换的内容在保持其宽⾼⽐的同时填充元素的整个内容框。如果对 象的宽⾼⽐与容器不同，那么该对象将被剪裁以填充容器。（容器内不会留下任何空⽩）</li><li><code>object-fit: contain;</code> ：被替换的内容在保持其宽⾼⽐的同时，将被缩放，并尽可能地将其 内容在填充元素的内容框中。在保持宽⾼⽐的同时缩放图⽚，意味着某些⽅向上可能⽆法完全填充 容器（即，如果图⽚的宽⾼⽐与容器的宽⾼⽐不同，那么会在容器的⼀个⽅向上留下空⽩）。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>div {</span></span>
<span class="line"><span>  width: 1000px;</span></span>
<span class="line"><span>  height: 1000px;</span></span>
<span class="line"><span>  overflow: hidden;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>div &gt; img {</span></span>
<span class="line"><span>  width: 100%;</span></span>
<span class="line"><span>  height: 100%;</span></span>
<span class="line"><span>  object-fit: cover; /* object-fit: contain; */</span></span>
<span class="line"><span> }</span></span></code></pre></div><p>这⾥提⼀下，把图⽚⽤作背景图，设置 background-size 也是⼀样的 3. 通过 <code>zoom</code> 或者 <code>transform:scale</code> 直接缩放图⽚。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>img {</span></span>
<span class="line"><span> zoom: 1.5 /* 根据需要调整放⼤⽐例 */</span></span>
<span class="line"><span> transform: scale(1.5); /* 根据需要调整放⼤⽐例 */</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="常⻅图片懒加载方式有哪些" tabindex="-1">常⻅图⽚懒加载⽅式有哪些？ <a class="header-anchor" href="#常⻅图片懒加载方式有哪些" aria-label="Permalink to &quot;常⻅图⽚懒加载⽅式有哪些？&quot;">​</a></h2><p>图片懒加载可以延迟图片的加载，只有当图片即将进入视口范围时才进行加载。这可以大大减轻页面的加载时间，并降低带宽消耗，提高了用户的体验。以下是一些常见的实现方法:</p><ol><li>Intersection Observer API Intersection 0bserver API 是一种用于异步检查文档中元素与视口叠加程度的API。可以将其用于检测图片是否已经进入视口，并根据需要进行相应的处理。</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let observer = new IntersectionObserver(function (entries) {</span></span>
<span class="line"><span>  entries.forEach(function (entry) {</span></span>
<span class="line"><span>    if (entry.isIntersecting) {</span></span>
<span class="line"><span>      const lazyImage = entry.target;</span></span>
<span class="line"><span>      lazyImage.src = lazyImage.dataset.src;</span></span>
<span class="line"><span>      observer.unobserve(lazyImage);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  });</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span>const lazyImages = [...document.querySelectorAll(&quot;.lazy&quot;)];</span></span>
<span class="line"><span>lazyImages.forEach(function (image) {</span></span>
<span class="line"><span>  observer.observe(image);</span></span>
<span class="line"><span>})</span></span></code></pre></div><p>2.自定义监听器 可以通过自定义监听器来实现懒加载。其中，应该避免在滚动事件处理程序中频繁进行图片加载，因为这可能会影响性能。相反，使用自定义监听器只会在滚动停止时进行图片加载。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function lazyLoad() {</span></span>
<span class="line"><span>  const images = document.querySelectorAll(&quot;.lazy&quot;);</span></span>
<span class="line"><span>  const scrollTop = window.pageYOffset;</span></span>
<span class="line"><span>  images.forEach((img) =&gt; {</span></span>
<span class="line"><span>    if (img.offsetTop &lt; window.innerHeight + scrollTop){</span></span>
<span class="line"><span>      img.src = img.dataset.src;</span></span>
<span class="line"><span>      img.classList.remove(&quot;lazy&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  });</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let lazyLoadThrottleTimeout;</span></span>
<span class="line"><span>document.addEventListener(&quot;scroll&quot;, function () {</span></span>
<span class="line"><span>  if (lazyLoadThrottleTimeout) {</span></span>
<span class="line"><span>    clearTimeout(lazyLoadThrottleTimeout);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  lazyLoadThrottleTimeout = setTimeout(lazyLoad, 20);</span></span>
<span class="line"><span>});</span></span></code></pre></div><p>在这个例子中，我们使用了 setTimeout()中对性能的影响。 无论使用哪种方法，都需要为需要懒加载的图片设置占位符，并将未加载的图片路径保存在 data 属性中，以便在需要时进行加载。这些占位符可以是简单的 div 或样式类，用于预留图片的空间，避免页面布局的混乱。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;!-- 占位符⽰例 --&gt;</span></span>
<span class="line"><span>&lt;div class=&quot;lazy-placeholder&quot; style=&quot;background-color: #ddd;height: 500px;&quot;&lt;/div&gt;</span></span>
<span class="line"><span>&lt;!-- 图⽚⽰例 --&gt;</span></span>
<span class="line"><span>&lt;img class=&quot;lazy&quot; data-src=&quot;path/to/image.jpg&quot; alt=&quot;预览图&quot; /&gt;</span></span></code></pre></div><p>总体来说，图片懒加载是一种这很简单，但非常实用的优化技术，能够显著提高网页的性能和用户体验。</p>`,61)]))}const E=i(p,[["render",e]]);export{o as __pageData,E as default};
