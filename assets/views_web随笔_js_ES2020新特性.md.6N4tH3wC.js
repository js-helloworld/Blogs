import{_ as s,c as n,a2 as e,o as p}from"./chunks/framework.CjNeJe2C.js";const h=JSON.parse('{"title":"ES2020 新特性","description":"","frontmatter":{"title":"ES2020 新特性","date":"2020-05-13T00:00:00.000Z","tags":["js","ES2020"],"categories":["js"],"author":["游城走不动"]},"headers":[],"relativePath":"views/web随笔/js/ES2020新特性.md","filePath":"views/web随笔/js/ES2020新特性.md"}'),t={name:"views/web随笔/js/ES2020新特性.md"};function l(i,a,o,c,d,r){return p(),n("div",null,a[0]||(a[0]=[e(`<h2 id="es2020-新特性" tabindex="-1">ES2020 新特性 <a class="header-anchor" href="#es2020-新特性" aria-label="Permalink to &quot;ES2020 新特性&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>JavaScript规范由称为TC39的委员会进行管理和迭代。TC39由各种开发人员，学术界人士和平台爱好者组成</p></div><h3 id="_1-promise-allsettled" tabindex="-1">1. Promise.allSettled <a class="header-anchor" href="#_1-promise-allsettled" aria-label="Permalink to &quot;1. Promise.allSettled&quot;">​</a></h3><ul><li>Promise.all接受一系列promise，并同时获取其结果。如果它们全部成功，Promise.all成功。如果一项或多项失败，Promise就会被reject</li><li>Promise.allSettled允许我们传递一系列的Promise，这些Promise将在全部结束后，Promise的返回值是一个装满Promise结果的数组</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Promise.allSettled([</span></span>
<span class="line"><span>    Promise.reject({code: 500, msg: &#39;服务异常&#39;}),</span></span>
<span class="line"><span>    Promise.resolve({ code: 200, list: []}),</span></span>
<span class="line"><span>    Promise.resolve({code: 200, list: []})</span></span>
<span class="line"><span>])</span></span>
<span class="line"><span>.then((ret) =&gt; {</span></span>
<span class="line"><span>    /*</span></span>
<span class="line"><span>        0: {status: &quot;rejected&quot;, reason: {...}}</span></span>
<span class="line"><span>        1: {status: &quot;fulfilled&quot;, value: {...}}</span></span>
<span class="line"><span>        2: {status: &quot;fulfilled&quot;, value: {...}}</span></span>
<span class="line"><span>    */</span></span>
<span class="line"><span>    // 过滤掉 rejected 状态，尽可能多的保证页面区域数据渲染</span></span>
<span class="line"><span>    RenderContent(ret.filter((el) =&gt; {</span></span>
<span class="line"><span>        return el.status !== &#39;rejected&#39;;</span></span>
<span class="line"><span>    }));</span></span>
<span class="line"><span>});</span></span></code></pre></div><h3 id="_2-可选链" tabindex="-1">2. 可选链 <a class="header-anchor" href="#_2-可选链" aria-label="Permalink to &quot;2. 可选链&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let obj = a &amp;&amp; a.c &amp;&amp; a.c.b;//防止出现undefined</span></span></code></pre></div><p>用了 Optional Chaining ，上面代码会变成</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let obj = a?.b?.c;</span></span></code></pre></div><h3 id="_3-空值合并运算符" tabindex="-1">3. 空值合并运算符 <a class="header-anchor" href="#_3-空值合并运算符" aria-label="Permalink to &quot;3. 空值合并运算符&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>null || 1  //1</span></span>
<span class="line"><span>undefined || 1  //1</span></span>
<span class="line"><span>0 || 1  //1</span></span>
<span class="line"><span>&quot;&quot; || 1  //1</span></span>
<span class="line"><span>NaN || 1  //1</span></span></code></pre></div><p>使用空值合并运算符</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>null ?? 1  //1</span></span>
<span class="line"><span>undefined ?? 1  //1</span></span>
<span class="line"><span>0 ?? 1  //0</span></span>
<span class="line"><span>&quot;&quot; ?? 1  //&quot;&quot;</span></span>
<span class="line"><span>NaN ?? 1  //NaN</span></span></code></pre></div><h3 id="_4-dynamic-import" tabindex="-1">4. dynamic-import <a class="header-anchor" href="#_4-dynamic-import" aria-label="Permalink to &quot;4. dynamic-import&quot;">​</a></h3><ul><li>由于webpack的支持，这是您可能已经熟悉的一种方式。并且在生产JavaScript应用程序中经常使用它来进行“代码拆分”。代码拆分在单个页面应用程序中非常强大。在许多情况下，可以大大加快初始页面加载时间。</li><li>动态导入语法允许我们将import作为能够返回promise的函数进行调用。这对于在代码运行时动态加载模块特别有用。例如，您可能想基于代码中的某些逻辑来加载某个组件或模块。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  const cpt = await import(&quot;components/cpt&quot;);</span></span>
<span class="line"><span>  cpt.run()</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>async function runCpt(type = &quot;desktop&quot;) {</span></span>
<span class="line"><span>    const cpt = await import(\`components/\${type}/cpt\`);</span></span>
<span class="line"><span>    cpt.run();</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="_5-bigint" tabindex="-1">5. BigInt <a class="header-anchor" href="#_5-bigint" aria-label="Permalink to &quot;5. BigInt&quot;">​</a></h3><p>Number 类型只能安全的表示-(2^53-1)至 2^53-1 范的值，即 Number.MIN_SAFE_INTEGER 至 Number.MAX_SAFE_INTEGER，超出这个范围的整数计算或者表示会丢失精度。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var num = Number.MAX_SAFE_INTEGER;  // -&gt; 9007199254740991</span></span>
<span class="line"><span></span></span>
<span class="line"><span>num = num + 1; // -&gt; 9007199254740992</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 再次加 +1 后无法正常运算</span></span>
<span class="line"><span>num = num + 1; // -&gt; 9007199254740992</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 两个不同的值，却返回了true</span></span>
<span class="line"><span>9007199254740992 === 9007199254740993  // -&gt; true</span></span></code></pre></div><p>为解决此问题，ES2020 提供一种新的数据类型：BigInt。使用 BigInt 有两种方式：</p><ol><li>在整数字面量后面加n。</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var bigIntNum = 9007199254740993n;</span></span></code></pre></div><ol start="2"><li>使用 BigInt 函数。</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var bigIntNum = BigInt(9007199254740);</span></span>
<span class="line"><span>var anOtherBigIntNum = BigInt(&#39;9007199254740993&#39;);</span></span></code></pre></div><p>通过 BigInt， 我们可以安全的进行大数整型计算。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var bigNumRet = 9007199254740993n + 9007199254740993n; // -&gt; -&gt; 18014398509481986n</span></span>
<span class="line"><span></span></span>
<span class="line"><span>bigNumRet.toString(); // -&gt; &#39;18014398509481986&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>typeof 9007199254740993n; // -&gt; &#39;bigint&#39;</span></span></code></pre></div><h3 id="_6-globalthis" tabindex="-1">6. globalThis <a class="header-anchor" href="#_6-globalthis" aria-label="Permalink to &quot;6. globalThis&quot;">​</a></h3><ul><li><p>JavaScript 在不同的环境获取全局对象有不同的方式，NodeJS 中通过 global, Web 中通过 window, self 等，有些甚至通过 this 获取，但通过 this 是及其危险的，this 在 JavaScript 中异常复杂，它严重依赖当前的执行上下文，这些无疑增加了获取全局对象的复杂性。</p></li><li><p>过去获取全局对象，可通过一个全局函数:</p></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var getGlobal = function () {</span></span>
<span class="line"><span>  if (typeof self !== &#39;undefined&#39;) { return self; }</span></span>
<span class="line"><span>  if (typeof window !== &#39;undefined&#39;) { return window; }</span></span>
<span class="line"><span>  if (typeof global !== &#39;undefined&#39;) { return global; }</span></span>
<span class="line"><span>  throw new Error(&#39;unable to locate global object&#39;);</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var globals = getGlobal();</span></span></code></pre></div><p>而 globalThis 目的就是提供一种标准化方式访问全局对象，有了 globalThis后，你可以在任意上下文，任意时刻都能获取到全局对象。</p><h3 id="_7-string-prototype-matchall" tabindex="-1">7. String.prototype.matchAll <a class="header-anchor" href="#_7-string-prototype-matchall" aria-label="Permalink to &quot;7. String.prototype.matchAll&quot;">​</a></h3><p>String.prototype.matchAll是一个实用函数，用于获取特定正则表达式的所有匹配项</p>`,33)]))}const g=s(t,[["render",l]]);export{h as __pageData,g as default};
