---
title: 随笔
date: 2024-10-13
tags:
 - 面试
categories:
 - 面试
---


## 1. 面试题：new操作符具体做了什么
<details open>
  <summary>new操作符具体做了什么</summary>

```javascript
function create( fn , ...args ){
    //1. 创建了一个空的对象
    var obj = {}; //var obj = Object.create({})
    //2. 将空对象的原型，指向于构造函数的原型
    Object.setPrototypeOf(obj,fn.prototype);
    //3. 将空对象作为构造函数的上下文（改变this指向）
    var result = fn.apply(obj,args);
    //4. 对构造函数有返回值的处理判断
    return result instanceof Object ? result : obj;
  }
```
</details>

## 2. 有听过函数防抖和函数节流吗？

<details open>
  <summary>函数防抖（debounce）</summary>

```javascript
// 防抖的中心思想在于：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。
    function debounce(fn,duration) {
        let timer = null
        return function(...args) {
          const context = this
          if (timer) {
            clearTimeout(timer)
          }
          timer = setTimeout(function() {
            fn.apply(context, args)
          }, duration)
        }
      }
```
</details>

<details open>
   <summary>函数节流（throttle）</summary>

```javascript
      // throttle 的中心思想在于：在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。
      function throttle (fn, duration) {
        // last为上一次触发回调的时间
        let last = 0

        return function(...args) {
          const context = this
          const now = Date.now()
          // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值
          if (now - last >= duration) {
            last = now
            fn.apply(context, args)
          }
        }
      }
```
</details>

## 3. 请描述event-loop的机制, 什么是宏任务和微任务，两者有什么区别？

```
在Job queue中的队列分为两种类型：macro-task和microTask。我们举例来看执行顺序的规定，我们设

macro-task队列包含任务: a1, a2 , a3
micro-task队列包含任务: b1, b2 , b3

执行顺序为，首先执行marco-task队列开头的任务，也就是 a1 任务，执行完毕后，在执行micro-task队列里的所有任务，也就是依次执行b1, b2 , b3，执行完后清空micro-task中的任务，接着执行marco-task中的第二个任务，依次循环。

了解完了macro-task和micro-task两种队列的执行顺序之后，我们接着来看，真实场景下这两种类型的队列里真正包含的任务（我们以node V8引擎为例），在node V8中，这两种类型的真实任务顺序如下所示：

macro-task队列真实包含任务：

script(主程序代码),setTimeout, setInterval, setImmediate, I/O, UI rendering

micro-task队列真实包含任务：
process.nextTick, Promises, Object.observe, MutationObserver

由此我们得到的执行顺序应该为：

script(主程序代码)—>process.nextTick—>Promises...——>setTimeout——>setInterval——>setImmediate——> I/O——>UI rendering

在ES6中macro-task队列又称为ScriptJobs，而micro-task又称PromiseJobs

## 什么宏任务和微任务，两者有什么区别？

宏任务：setTimeout、setInterval、Ajax、DOM时间
微任务：Promise async/await
微任务是ES6语法规定的
宏任务是浏览器规定的
微任务执行时机比宏任务早（微任务在DOM渲染前执行，宏任务在DOM渲染后执行）

setTimeout(function(){console.log(1)},0);

new Promise(function(resolve,reject){
   console.log(2);
   resolve();
}).then(function(){console.log(3)
}).then(function(){console.log(4)});

process.nextTick(function(){console.log(5)});

console.log(6);
//输出2,6,5,3,4,1

setTimeout(function(){console.log(1)},0);

new Promise(function(resolve,reject){
   console.log(2);
   setTimeout(function(){resolve()},0)
}).then(function(){console.log(3)
}).then(function(){console.log(4)});

process.nextTick(function(){console.log(5)});

console.log(6);

//输出的是  2 6 5 1 3 4
```
参考文章：
[从promise、process.nextTick、setTimeout出发，谈谈Event Loop中的Job queue](https://github.com/forthealllight/blog/issues/5)


